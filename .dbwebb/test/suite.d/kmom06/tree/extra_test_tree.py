#!/usr/bin/env python3
"""
An autogenerated testfile for python.
"""

import io
import unittest
import unittest.mock
import os
import random
import sys
from io import StringIO
from unittest.mock import patch
from unittest import TextTestRunner
from examiner import ExamTestCase, ExamTestResult, tags
from examiner import import_module, find_path_to_assignment


FILE_DIR = os.path.dirname(os.path.realpath(__file__))
REPO_PATH = find_path_to_assignment(FILE_DIR)

if REPO_PATH not in sys.path:
    sys.path.insert(0, REPO_PATH)

# Path to file and basename of the file to import
BST = import_module(REPO_PATH, 'bst').BinarySearchTree

class Test3BST(ExamTestCase):
    """
    Testing the class List.
    """
    @classmethod
    def setUpClass(cls):
        """
        Is needed it the students write and read to files.
        """
        os.chdir(REPO_PATH)
        
    @staticmethod
    def list_to_bst(seq, bst):
        """
        Take list and insert value in BST.
        """
        for v in seq:
            bst.insert(v, str(v))

    @staticmethod
    def is_bst(root, l=None, r=None, parent=None):
        """Check is a tree fullfilles Binary Search Tree rules"""
        # Base condition
        if root is None:
            return True
        # if left node exist then check it has
        # correct data or not i.e. left node's data
        # should be less than root's data
        if l is not None and root.key < l.key:
            raise KeyError(f"Node with key {root.key}'s left child is not lower, it is {l.key}")
        # if right node exist then check it has
        # correct key or not i.e. right node's key
        # should be greater than root's key
        if r is not None and root.key > r.key:
            raise KeyError(f"Node with key {root.key}'s right child is not higher, it is {r.key}")

        # if check that the parent is correct node
        if root.parent is not parent:
            raise KeyError((
                f"Expected Node with key {root.key} to have parent with key {parent.key}"
                f" but it is {root.parent.key}"
            ))

        # check recursively for every node.
        return Test2BST.is_bst(root.left, l, root, root) and \
            Test2BST.is_bst(root.right, root, r, root)




    @tags("len")
    def test_a_len(self):
        """
        __len__().
        Testar att använda len() på trädet och kolla att rätt antal returneras.
        Trädet är skapat med följande element. Elementet används som nyckel och görs till en sträng för värdet.
        {arguments}
        Förväntar att följande returneras:
        {correct}
        Fick:
        {student}
        """
        seq = [5, 2, 10, 7, 12, 11]
        self._argument = seq
        bst = BST()
        self.list_to_bst(seq, bst)
        self.assertEqual(len(bst), 6)

    @tags("len")
    def test_b_len_empty(self):
        """
        __len__().
        Testar att använda len() på trädet och kolla att rätt antal returneras när trädet är tomt.
        Förväntar att följande returneras:
        {correct}
        Fick:
        {student}
        """
        bst = BST()
        self.assertEqual(len(bst), 0)


    @tags("getitem")
    def test_c_getitem(self):
        """
        __getitem__().
        Testar att använda [key] funkar på trädet och kolla att rätt värde returneras.
        Trädet är skapat med följande element. Elementet används som nyckel och görs till en sträng för värdet.
        {arguments}
        Förväntar att följande returneras när gör bst[7]:
        {correct}
        Fick:
        {student}
        """
        seq = [5, 2, 10, 7, 12, 11]
        self._argument = seq
        bst = BST()
        self.list_to_bst(seq, bst)
        self.assertEqual(bst[7], "7")


    @tags("setitem")
    def test_d_setitem(self):
        """
        __setitem__().
        Testar att tilldela med "[10] = 'tree'" trädet och kolla att det läggs till korrekt.
        Trädet är skapat med följande element. Elementet används som nyckel och görs till en sträng för värdet.
        {arguments}
        Förväntar att bst.get(10) returnerar följande värde:
        {correct}
        Fick:
        {student}
        """
        seq = [5, 2, 10, 7, 12, 11]
        self._argument = seq
        bst = BST()
        self.list_to_bst(seq, bst)
        bst.insert(10, "tree")
        self.assertEqual(bst.get(10), "tree")


    @tags("contains")
    def test_e_contains(self):
        """
        __contains__().
        Testar att "12 in bst" returnerar True.
        Trädet är skapat med följande element. Elementet används som nyckel och görs till en sträng för värdet.
        {arguments}
        Förväntar att "100 in bst" returnerar följande värde:
        {correct}
        Fick:
        {student}
        """
        seq = [5, 2, 10, 7, 12, 11]
        self._argument = seq
        bst = BST()
        self.list_to_bst(seq, bst)
        self.assertTrue(12 in bst)


    @tags("contains")
    def test_f_contains_false(self):
        """
        __contains__().
        Testar att "100 in bst" returnerar False.
        Trädet är skapat med följande element. Elementet används som nyckel och görs till en sträng för värdet.
        {arguments}
        Förväntar att "100 in bst" returnerar följande värde:
        {correct}
        Fick:
        {student}
        """
        seq = [5, 2, 10, 7, 12, 11]
        self._argument = seq
        bst = BST()
        self.list_to_bst(seq, bst)
        self.assertFalse(100 in bst)


if __name__ == '__main__':
    runner = TextTestRunner(resultclass=ExamTestResult, verbosity=2)
    unittest.main(testRunner=runner, exit=False)
